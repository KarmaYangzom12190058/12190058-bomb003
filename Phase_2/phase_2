  gdb bomb										//gdb debugger executes the assembly code
  (gdb) break phase_2									//breakpoint is set at phase 2 to avoid exploding of bomb when input is wrong
  (gdb) r result.txt									//write the string of phase_1 and save as result.txt file. run the program using result.txt
  Starting program: /home/yang/Desktop/ITS304 CS1/Assignment_1/bomb003/bomb result.txt	
  Welcome to my fiendish little bomb. You have 6 phases with
  which to blow yourself up. Have a nice day!
  Phase 1 defused. How about the next one?
  1 2 3 4 5 6										//input any random numbers 

  Breakpoint 1, 0x0000000000400ea9 in phase_2 ()	
  
  (gdb) disas										//opens assembly file
  Dump of assembler code for function phase_2:
  => 0x0000000000400ea9 <+0>:	push   %rbp						
     0x0000000000400eaa <+1>:	push   %rbx
     0x0000000000400eab <+2>:	sub    $0x28,%rsp					//creating stack frame with 56 bytes
     0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
     0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
     0x0000000000400ebd <+20>:	xor    %eax,%eax
     0x0000000000400ebf <+22>:	mov    %rsp,%rsi
     0x0000000000400ec2 <+25>:	callq  0x40144c <read_six_numbers>			//input should be 6 integers
     0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)					
     0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>
     0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)
     0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>
     0x0000000000400ed4 <+43>:	callq  0x40142a <explode_bomb>
     0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
     0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
     0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
     0x0000000000400ee4 <+59>:	add    (%rbx),%eax
     0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)
     0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>
     0x0000000000400eeb <+66>:	callq  0x40142a <explode_bomb>
     0x0000000000400ef0 <+71>:	add    $0x4,%rbx
     0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx
     0x0000000000400ef7 <+78>:	jne    0x400ee1 <phase_2+56>
     0x0000000000400ef9 <+80>:	mov    0x18(%rsp),%rax
     0x0000000000400efe <+85>:	xor    %fs:0x28,%rax
     0x0000000000400f07 <+94>:	je     0x400f0e <phase_2+101>
     0x0000000000400f09 <+96>:	callq  0x400b00 <__stack_chk_fail@plt>
     0x0000000000400f0e <+101>:	add    $0x28,%rsp
     0x0000000000400f12 <+105>:	pop    %rbx
     0x0000000000400f13 <+106>:	pop    %rbp
     0x0000000000400f14 <+107>:	retq   
  End of assembler dump.
  
  (gdb) until* 0x0000000000400ec7							//to directly jump in line <+30>
  (gdb) disas
  Dump of assembler code for function phase_2:
     0x0000000000400ea9 <+0>:	push   %rbp						
     0x0000000000400eaa <+1>:	push   %rbx
     0x0000000000400eab <+2>:	sub    $0x28,%rsp					
     0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
     0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
     0x0000000000400ebd <+20>:	xor    %eax,%eax
     0x0000000000400ebf <+22>:	mov    %rsp,%rsi
     0x0000000000400ec2 <+25>:	callq  0x40144c <read_six_numbers>			
  => 0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)					//compares 0x0 and first number(%rsp)	
     0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>
     0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)
     0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>


  (gdb) i r 								//info registers: prints the values of all registers							
  rax            0x6                 6
  rbx            0x7fffffffdf58      140737488346968
  rcx            0x0                 0
  rdx            0x7fffffffde34      140737488346676
  rsi            0x0                 0
  rdi            0x7fffffffd7b0      140737488345008
  rbp            0x0                 0x0
  rsp            0x7fffffffde20      0x7fffffffde20
  r8             0xffffffff          4294967295


  (gdb) x/d 0x7fffffffde20								//value of rsp register in decimal
  0x7fffffffde20:	1
  
  So, 0 and 1 is compared and shows that they are not equal. If the two numbers are not equal, it will jump to line <+43> and the bomb will be exploded. 
  From here, we know that the first input number should be equal to 0 and the function will move towards line <+36>.
  
  
  (gdb) r result.txt									//Now, insert 0 as first number
  Starting program: /home/yang/Desktop/ITS304 CS1/Assignment_1/bomb003/bomb result.txt	
  Welcome to my fiendish little bomb. You have 6 phases with
  which to blow yourself up. Have a nice day!
  Phase 1 defused. How about the next one?
  0 2 3 4 5 6										
  
  Breakpoint 1, 0x0000000000400ea9 in phase_2 ()	
	
  (gdb) until *0x0000000000400ecd							//to directly jump in line <+36>
  (gdb) disas 
  Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40144c <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>
=> 0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)					//compares 0x1 and second number(%rsp)
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>
   0x0000000000400ed4 <+43>:	callq  0x40142a <explode_bomb>
   0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp


  (gdb) p/x * (int *) ($rsp +0x4)							//value of rsp register in decimal
  $1 = 0x2

  So, 1 and 2 is compared and shows that they are not equal. If the two numbers are not equal, it will jump to line <+43> and the bomb will be exploded. 
  From here, we know that the second input number should be equal to 1 and the function will move towards line <+48>.
  
  
  For third input number, follow the same procedure. Insert 0 and 1 as the first two input number. Run the disassembler and reaches line <+48>.
  
  (gdb) r result.txt									//Now, insert 0 and 1 as first two numbers
  Starting program: /home/yang/Desktop/ITS304 CS1/Assignment_1/bomb003/bomb result.txt	
  Welcome to my fiendish little bomb. You have 6 phases with
  which to blow yourself up. Have a nice day!
  Phase 1 defused. How about the next one?
  0 1 3 4 5 6										
  
  Breakpoint 1, 0x0000000000400ea9 in phase_2 ()
  
  (gdb) until *0x0000000000400ed9							//to directly jump in line <+48>
  (gdb) disas
  Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40144c <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>
   0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>
   0x0000000000400ed4 <+43>:	callq  0x40142a <explode_bomb>
=> 0x0000000000400ed9 <+48>:	mov    %rsp,%rbx					
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
   0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
   0x0000000000400ee4 <+59>:	add    (%rbx),%eax
   0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)
   0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>


  After doing operations such as mov, add and lea, it will reach at line <+61>.
  
  (gdb) ni 4										//next instruction 
  (gdb) disas
  Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40144c <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>
   0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>
   0x0000000000400ed4 <+43>:	callq  0x40142a <explode_bomb>
   0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
   0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
   0x0000000000400ee4 <+59>:	add    (%rbx),%eax
=> 0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)					//compare eax(1) and rbx(0)
   0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>
   0x0000000000400eeb <+66>:	callq  0x40142a <explode_bomb>
   0x0000000000400ef0 <+71>:	add    $0x4,%rbx
   0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx

 
  So, 1 and 0 is compared and shows that they are not equal. If the two numbers are not equal, it will jump to line <+66> and the bomb will be exploded. 
  From here, we know that the third input number should be equal to 1 and the function will move towards line <+64> and calls je (jump if equal to).
  
  
  For remaining three input number, follow the same procedure as above. 
  
  Description:
  Phase 2 is about giving a set of 6 numbers. If the given input 6 numbers is equal with the answer 6 numbers, then bomb at phase 2 is defused. 
  The numbers used for defusing phase 2 of bomb 003 are "0 1 1 2 3 5" (First 6 fibonacci series numbers).
  
